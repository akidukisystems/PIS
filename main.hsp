    /* Shift JIS */    
    
    #packopt name "main"

    #include "cfg.as"
    #include "hsp3utf.as"
    #include "msglib.as"
    #include "hspda.as"

    #module

        #uselib "winmm.dll"
        #cfunc timeGetTime "timeGetTime"

        #deffunc settick int tickID
            SetTick_int.tickID = timeGetTime()
        return

        #defcfunc gettick int tickID
        return timeGetTime() - SetTick_int.tickID

    #global

    // 画面サイズ指定
    textsize_x    = 8
    textsize_y    = 16
    text_length   = 44
    text_line     = 3
    SCREEN_MAG    = 4

    #define     OFFSET_X        0
    #define     OFFSET_Y        1

    #enum   SCREEN_S = 0
    #enum   SCREEN_D
    #enum   SCREEN_CONTROL
    #enum   SCREEN_LOG
    #enum   SCREEN_DUMMY
    #enum   SCREEN_CEL
    #enum   SCREEN_PASSWORD
    #enum   SCREEN_EXTRAMSG
    #enum   SCREEN_CONFIG
 
    #enum   tickFpsCount = 0
    #enum   tickLangChange
    #enum   tickSomeBlinkDown
    #enum   tickSomeBlinkInterval
    #enum   tickTrainBlink
    #enum   tickScroll
    
    // ボタンサイズ指定
    #define     BTN_SIZE_X      128
    #define     BTN_SIZE_Y      32
    #define     BTN_MUL         2
    #define     SPACE           20

    #uselib "user32.dll"
    #func PostMessage "PostMessageA" int,int,int,int

    #define     MSG_USER         0x0400
    #define     MSG_CHANGED_DATA   ( MSG_USER + 0x101 )

    // 配列で使う定数
    #enum   eLine = 0
    #enum   eType
    #enum   eFor 
    #enum   eTime
    #enum   eCars

    // 日本語/英語
    #define j 0
    #define e 1

    // 2行目を描画するかの判定に使う
    // 列車が接近してない、列車接近メッセージが表示されていない、メッセージが表示されていない
    #define isCanview2ndLine ( ( isApproaching == 0 ) and ( isTrainmsg == 0 ) and ( isMsg == 0 ) )
    // ファイルが存在しないか
    #define isFileNotFound ( strsize == -1 )



    onexit gosub *l_exit

    buffer SCREEN_S, textsize_x*text_length+OFFSET_X, textsize_y*text_line+OFFSET_Y, 4

    screen SCREEN_D, (textsize_x*text_length+OFFSET_X)*SCREEN_MAG, (textsize_y*text_line+OFFSET_Y)*SCREEN_MAG, 4
    title "スクリーン"

    screen SCREEN_LOG, , , 4
    title "ログ"

    screen SCREEN_EXTRAMSG, , , 4
    title "臨時メッセージ編集"

    screen SCREEN_CONFIG, 320, 240, 4
    title "設定"

    objsize BTN_SIZE_X, BTN_SIZE_Y, 0
    button gosub "フレームレート表示切替", *l_config_fpschange
    button gosub "ログ画面表示", *l_config_log
    button gosub "このソフトについて", *l_author


    gsel SCREEN_CONFIG, -1
    gsel SCREEN_EXTRAMSG, -1

    buffer SCREEN_DUMMY

    screen SCREEN_CONTROL, BTN_SIZE_X *BTN_MUL *2, 480, 4
    title "操作ウインドウ"

    screen SCREEN_PASSWORD, 320, 240, 4
    title "パスワードを入力してください"

    mes "パスワードを入力してください"

    password = ""
    input password, 200, 24, 0

    button gosub "実行", *l_passwordEnter
    button gosub "キャンセル", *l_passwordCancel

    gsel SCREEN_PASSWORD, -1

    nowLoadingFile = ".\\entry\\entry.ini"

*reset

    isChangedFile = 0
    sdim msg_extra, , 10
    sdim imsg_extra, , 10
    dim isBlinkExtraMsg, 10

    gsel SCREEN_S
    cls : pos 0, 0

    gsel SCREEN_D
    cls : pos 0, 0

    gsel SCREEN_CONTROL
    cls : pos 0, 0

    gsel SCREEN_LOG
    cls : pos 0, 0

    init_msglib SCREEN_LOG

    putmes_msglib "起動中です　しばらくお待ちください。\n", SCREEN_LOG
    
    gsel SCREEN_CONTROL

    font "MS Gothic", 26
    objmode 2

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y *BTN_MUL, 0

    pos 0, 0 : button gosub "列車接近セット", *l_approaching_true
    pos BTN_SIZE_X *BTN_MUL, 0 : button gosub "列車接近リセット", *l_approaching_false

    objsize BTN_SIZE_X *( 1.0 *BTN_MUL *1.5 ), BTN_SIZE_Y *BTN_MUL, 0

    pos 0, BTN_SIZE_Y *BTN_MUL : button gosub "列車順送り", *l_next

    font "MS Gothic", 18
    objmode 2

    objsize BTN_SIZE_X, BTN_SIZE_Y *BTN_MUL, 0

    pos BTN_SIZE_X *( 1.0 *BTN_MUL *1.5 ), BTN_SIZE_Y *BTN_MUL : button gosub "列車戻し", *l_prev

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y *BTN_MUL, 0

    pos 0, ginfo_cy + SPACE : button gosub "メッセージ表示", *l_msg
    pos BTN_SIZE_X *BTN_MUL, ginfo_cy -BTN_SIZE_Y *BTN_MUL : button gosub "列車メッセージ表示", *l_trainmsg

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y, 0

    pos 0, ginfo_cy : button gosub "メッセージ順送り", *l_nextmsg
    button gosub "メッセージ戻し", *l_prevmsg

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y *BTN_MUL, 0

    pos BTN_SIZE_X *BTN_MUL, ginfo_cy -BTN_SIZE_Y *2 : button gosub "臨時メッセージ", *l_extramsg

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y *BTN_MUL, 0

    pos 0, ginfo_cy + SPACE : button gosub "画面を保存", *l_save
    pos BTN_SIZE_X *BTN_MUL, ginfo_cy -BTN_SIZE_Y *BTN_MUL : button gosub "リセット", *reset

    objsize BTN_SIZE_X *BTN_MUL, BTN_SIZE_Y, 0
    pos 0, ginfo_cy + SPACE : button gosub "設定", *l_config
    pos BTN_SIZE_X *BTN_MUL, ginfo_cy -BTN_SIZE_Y : button gosub "別のファイルを読込む", *l_select

    pos 0, ginfo_cy : button gosub "SMVファイルを書込む", *l_smartview_write
    pos BTN_SIZE_X *BTN_MUL, ginfo_cy -BTN_SIZE_Y : button gosub "SMVファイルを読込む", *l_smartview_read


    gsel SCREEN_D

    font "MS Gothic", 16

    // 初期化

    oncmd goto *l_changed_data, MSG_CHANGED_DATA

    entry = 0
    escapeStr = "$"

    fontname = "MS Gothic"
    fontsize = 16

    // ファイルは存在するか

    exist nowLoadingFile
    if ( isFileNotFound ) {

        dialog "\""+ nowLoadingFile +"\" が存在しません。別のファイルを参照してください。", 1, "ファイル読込みエラー"
        gosub *l_select

        goto *reset

    }

    // ファイルは暗号化されているか

    isPasswordEnter = 0
    isPasswordCancel = 0
    ;OverwritedImageFilePath = ""

    switch getpath( nowLoadingFile, 18 )

    /*case ".ceini"

        ZipExtract nowLoadingFile, dir_cur +"\\entry\\"

        OverwritedImageFilePath = 
*/
    case ".ein"

        exist nowLoadingFile
        filesize = strsize

        sdim encryptedfile, filesize
        sdim decryptedfile, filesize
        bload nowLoadingFile, encryptedfile

        password = ""

        // パスワード入力ダイアログ
        gsel SCREEN_PASSWORD, 1

        repeat

            if ( isPasswordEnter or isPasswordCancel ) : break

            wait 1

        loop

        gsel SCREEN_PASSWORD, -1

        if ( isPasswordCancel ) {

            dialog "\""+ nowLoadingFile +"\" が開けません。別のファイルを参照してください。", 1, "ファイル読込みエラー"
            gosub *l_select

            goto *reset

        }

        // 復号化

        tmp = 0
        chksum = 0

        if ( password == "" ) {

            dialog "復号化に失敗しました。\n理由：パスワードを入力してください。", 1, "ファイル復号化エラー"
            gosub *l_select

            goto *reset

        }

        if ( strmid( encryptedfile, 0, 4 ) != "EINI" ) {

            dialog "復号化に失敗しました。\n理由：復号化できる種類のファイルではありません。", 1, "ファイル復号化エラー"
            gosub *l_select

            goto *reset

        }

        repeat filesize -8
    
            poke decryptedfile, cnt, peek( encryptedfile, cnt +8 ) xor peek( password, tmp )
            chksum += peek( encryptedfile, cnt +8 ) xor peek( password, tmp )

            tmp ++
            if ( tmp == strlen( password ) ) : tmp = 0

        loop

        if ( lpeek( encryptedfile, 4 ) != chksum ) {
            
            dialog "復号化に失敗しました。\n理由：チェックサムが一致しません。パスワードが間違っているか、ファイルが改ざんされている可能性があります。", 1, "ファイル復号化エラー"
            gosub *l_select

            goto *reset

        }

        cfgAS_initmem decryptedfile

    swbreak

    case ".ini"

        cfgAS_init nowLoadingFile

    swbreak

    swend

    cfgAS_read "escapestr", escapeStr
    cfgAS_read "font.name", fontname
    cfgAS_read "font.size", fontsize

    cfgAS_read "entrycount", entry



    sdim msg_Line, 64, 2, entry
    sdim msg_Type, 64, 2, entry
    sdim msg_For, 64, 2, entry
    sdim msg_Time, 64, 2, entry
    sdim msg_Cars, 64, 2, entry

    msgSections = 10

    sdim msg_thisTrainMsg, 64, msgSections, entry
    dim imsg_thisTrainMsg, msgSections, entry

    msgEntry = 0

    sdim msg_msg, 64, msgSections, msgEntry
    dim imsg_msg, msgSections, msgEntry

    dim isBlinkThisTrainMsg, msgSections, entry
    dim isBlinkMsg, msgSections, msgEntry

    dim imsg_Line, entry
    dim imsg_Type, entry
    dim imsg_For, entry
    dim imsg_Time, entry
    dim imsg_Cars, entry

    dim isBold, 5, entry
    dim isBlink, 5, entry

    sdim msg_Approaching, 64, 2

    imsg_Approaching = $FF0000

    dim msgoffset, 5

    isBlinking = 0
    
    roll = 0

    isMsg = 0
    isTrainmsg = 0
    isExtraMsg = 0

    isApproaching = 0
    isApproachingView = 0
    isEng = 0

    beforeMsg = -1
    nowTrain = 0
    nowMsg = 0

    celImagePath = ""
    embedImageNumSize = 4

    putmes_msglib "変数を初期化しました\n", SCREEN_LOG
    putmes_msglib "読込むファイル：\""+ nowLoadingFile +"\"\n", SCREEN_LOG
    putmes_msglib "列車エントリ数："+ entry +"\n", SCREEN_LOG

    // 読み込み

    repeat entry

        // 整合性を保つために 空で埋める
        msg_Line.j.cnt          = ""
        msg_Type.j.cnt          = ""
        msg_For.j.cnt           = ""
        msg_Time.j.cnt          = ""
        msg_Cars.j.cnt          = ""

        msg_Line.e.cnt          = ""
        msg_Type.e.cnt          = ""
        msg_For.e.cnt           = ""
        msg_Time.e.cnt          = ""
        msg_Cars.e.cnt          = ""

        imsg_Line.cnt           = 0
        imsg_Type.cnt           = 0
        imsg_For.cnt            = 0
        imsg_Time.cnt           = 0
        imsg_Cars.cnt           = 0

        isBold.eLine.cnt        = 0
        isBold.eType.cnt        = 0
        isBold.eFor.cnt         = 0
        isBold.eTime.cnt        = 0
        isBold.eCars.cnt        = 0

        isBlink.eLine.cnt       = 0
        isBlink.eType.cnt       = 0
        isBlink.eFor.cnt        = 0
        isBlink.eTime.cnt       = 0
        isBlink.eCars.cnt       = 0

        cfgAS_read "msg_Line.j."+ cnt +"", msg_Line.j.cnt
        cfgAS_read "msg_Type.j."+ cnt +"", msg_Type.j.cnt
        cfgAS_read "msg_For.j."+ cnt +"", msg_For.j.cnt
        cfgAS_read "msg_Time.j."+ cnt +"", msg_Time.j.cnt
        cfgAS_read "msg_Cars.j."+ cnt +"", msg_Cars.j.cnt

        cfgAS_read "msg_Line.e."+ cnt +"", msg_Line.e.cnt
        cfgAS_read "msg_Type.e."+ cnt +"", msg_Type.e.cnt
        cfgAS_read "msg_For.e."+ cnt +"", msg_For.e.cnt
        cfgAS_read "msg_Time.e."+ cnt +"", msg_Time.e.cnt
        cfgAS_read "msg_Cars.e."+ cnt +"", msg_Cars.e.cnt

        if ( msg_Line.e.cnt == escapeStr ) : msg_Line.e.cnt = msg_Line.j.cnt
        if ( msg_Type.e.cnt == escapeStr ) : msg_Type.e.cnt = msg_Type.j.cnt
        if ( msg_For.e.cnt == escapeStr ) : msg_For.e.cnt = msg_For.j.cnt
        if ( msg_Time.e.cnt == escapeStr ) : msg_Time.e.cnt = msg_Time.j.cnt
        if ( msg_Cars.e.cnt == escapeStr ) : msg_Cars.e.cnt = msg_Cars.j.cnt

        before_cnt = cnt

        repeat msgSections

            msg_thisTrainMsg.cnt.before_cnt     = ""
            imsg_thisTrainMsg.cnt.before_cnt    = 0
            isBlinkThisTrainMsg.cnt.before_cnt  = 0

            cfgAS_read "msg_thisTrainMsg."+ cnt +"."+ before_cnt +"", msg_thisTrainMsg.cnt.before_cnt
            cfgAS_read "imsg_thisTrainMsg."+ cnt +"."+ before_cnt +"", imsg_thisTrainMsg.cnt.before_cnt
            cfgAS_read "isBlinkThisTrainMsg."+ cnt +"."+ before_cnt +"", isBlinkThisTrainMsg.cnt.before_cnt

            if ( msg_thisTrainMsg.cnt.before_cnt == "$" ) : break

            await 1

        loop

        cfgAS_read "imsg_Line."+ cnt +"", imsg_Line.cnt
        cfgAS_read "imsg_Type."+ cnt +"", imsg_Type.cnt
        cfgAS_read "imsg_For."+ cnt +"", imsg_For.cnt
        cfgAS_read "imsg_Time."+ cnt +"", imsg_Time.cnt
        cfgAS_read "imsg_Cars."+ cnt +"", imsg_Cars.cnt

        cfgAS_read "isBold.Line."+ cnt +"", isBold.eLine.cnt
        cfgAS_read "isBold.Type."+ cnt +"", isBold.eType.cnt
        cfgAS_read "isBold.For."+ cnt +"", isBold.eFor.cnt
        cfgAS_read "isBold.Time."+ cnt +"", isBold.eTime.cnt
        cfgAS_read "isBold.Cars."+ cnt +"", isBold.eCars.cnt

        cfgAS_read "isBlink.Line."+ cnt +"", isBlink.eLine.cnt
        cfgAS_read "isBlink.Type."+ cnt +"", isBlink.eType.cnt
        cfgAS_read "isBlink.For."+ cnt +"", isBlink.eFor.cnt
        cfgAS_read "isBlink.Time."+ cnt +"", isBlink.eTime.cnt
        cfgAS_read "isBlink.Cars."+ cnt +"", isBlink.eCars.cnt

        putmes_msglib "エントリ "+ cnt +" のデータを読込みました\n", SCREEN_LOG

        await 1

    loop

    cfgAS_read "msg_Approaching.j", msg_Approaching.j
    cfgAS_read "msg_Approaching.e", msg_Approaching.e

    cfgAS_read "imsg_Approaching", imsg_Approaching

    cfgAS_read "msgentrycount", msgEntry

    sdim msg_msg, 64, msgSections, msgEntry
    dim imsg_msg, msgSections, msgEntry

    putmes_msglib "メッセージエントリ数："+ msgEntry +"\n", SCREEN_LOG

    repeat msgEntry

        before_cnt = cnt

        repeat msgSections

            msg_msg.cnt.before_cnt     = ""
            imsg_msg.cnt.before_cnt    = 0
            isBlinkMsg.cnt.before_cnt  = 0

            cfgAS_read "msg_msg."+ cnt +"."+ before_cnt +"", msg_msg.cnt.before_cnt
            cfgAS_read "imsg_msg."+ cnt +"."+ before_cnt +"", imsg_msg.cnt.before_cnt
            cfgAS_read "isBlinkMsg."+ cnt +"."+ before_cnt +"", isBlinkMsg.cnt.before_cnt

            if ( msg_msg.cnt.before_cnt == "$" ) : break

            await 1
            
        loop

        putmes_msglib "エントリ "+ cnt +" のデータを読込みました\n", SCREEN_LOG

    loop

    cfgAS_read "offset.Line", msgoffset.eLine
    cfgAS_read "offset.Type", msgoffset.eType
    cfgAS_read "offset.For", msgoffset.eFor
    cfgAS_read "offset.Time", msgoffset.eTime
    cfgAS_read "offset.Cars", msgoffset.eCars

    cfgAS_read "screen.textsize.x", textsize_x
    cfgAS_read "screen.textsize.y", textsize_y
    cfgAS_read "screen.text.length", text_length
    cfgAS_read "screen.text.lines", text_line
    cfgAS_read "screen.mag", SCREEN_MAG

    cfgAS_read "celimage", celImagePath

    celSize_x = 0
    celSize_y = 0

    if ( celImagePath != "" ) {

        cfgAS_read "celsize.x", celSize_x
        cfgAS_read "celsize.y", celSize_y

        celload celImagePath, SCREEN_CEL, 0
        celdiv SCREEN_CEL, celSize_x, celSize_y

    }

    putmes_msglib "スクリーン情報を読込みました\n", SCREEN_LOG

    oncmd 0

*l_SMVloaded

    buffer SCREEN_S, textsize_x*text_length+OFFSET_X, textsize_y*text_line+OFFSET_Y, 4

    screen SCREEN_D, (textsize_x*text_length+OFFSET_X)*SCREEN_MAG, (textsize_y*text_line+OFFSET_Y)*SCREEN_MAG, 4
    title "スクリーン"

    
    gsel SCREEN_S
    font fontname, fontsize

    gsel SCREEN_DUMMY
    font fontname, fontsize

    putmes_msglib "ready\n", SCREEN_LOG

    isFlash = 0

    settick tickFpsCount
    settick tickLangChange
    settick tickSomeBlinkDown
    settick tickSomeBlinkInterval
    settick tickTrainBlink
    settick tickScroll

    repeat  
        
        // ファイルが変更されたらリセット
        if ( isChangedFile ) : break

        gsel SCREEN_S  ;コピー元画面
        redraw 0
        color : boxf

        // 種別・行先・時刻・両数　点滅動作

        repeat text_line

            isShiftingLine = 0
            if ( ( isCanview2ndLine != 1 ) and ( cnt != 0 ) ) : isShiftingLine = 1

            if ( cnt == 1 ) {

                // 列車接近メッセージ　点滅動作
                if ( isApproachingView ) : rgbcolor imsg_Approaching : pos 0, textsize_y : mes msg_Approaching.isEng, 1

                // 列車メッセージスクロール
                if ( isTrainmsg ) {

                    // 右から左へ流す
                    pos 0-roll, textsize_y

                    msgsize = 0

                    repeat msgSections

                        if ( imsg_thisTrainMsg.cnt.nowTrain == 0 ) : break

                        if ( ( isBlinking and isBlinkThisTrainMsg.cnt.nowTrain ) == 0 ) {

                            if ( instr( msg_thisTrainMsg.cnt.nowTrain, 0, "$" ) == -1 ) {

                                rgbcolor imsg_thisTrainMsg.cnt.nowTrain
                                mes msg_thisTrainMsg.cnt.nowTrain, 1

                                msgsize += ginfo_mesx
    
                            } else {
    
                                sdim tmp
                                split msg_thisTrainMsg.cnt.nowTrain, "$", tmp
    
                                before_cnt = cnt
    
                                if ( tmp.0 != "" ) {
    
                                    rgbcolor imsg_thisTrainMsg.cnt.nowTrain : mes tmp.0, 1

                                    msgsize += ginfo_mesx
    
                                }
    
                                repeat length( tmp ) -1, 1
    
                                    if ( splitedcnt == cnt ) : break

                                    celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                    rgbcolor imsg_thisTrainMsg.before_cnt.nowTrain  : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                    msgsize += ginfo_mesx + celSize_x
    
                                loop
    
                            }

                        } else {

                            gsel SCREEN_DUMMY
                            
                            if ( instr( msg_thisTrainMsg.cnt.nowTrain, 0, "$" ) == -1 ) {

                                mes msg_thisTrainMsg.cnt.nowTrain
                                tmp = ginfo_mesx

                            } else {

                                tmp = 0

                                sdim string
                                split msg_thisTrainMsg.cnt.nowTrain, "$", string
    
                                before_cnt = cnt
    
                                if ( string.0 != "" ) {
    
                                    mes string.0

                                    tmp += ginfo_mesx
    
                                }
    
                                repeat length( string ) -1, 1
    
                                    if ( splitedcnt == cnt ) : break

                                    mes strmid( string.cnt, embedImageNumSize, strlen( string.cnt ) -embedImageNumSize )
                                    tmp += ginfo_mesx + celSize_x
    
                                loop

                            }

                            gsel SCREEN_S
                            msgsize += tmp
                            pos ginfo_cx + tmp, ginfo_cy

                        }

                    loop

                    if ( gettick( tickScroll ) >= 15 ) {
                        
                        settick tickScroll
                        roll ++

                    }

                    // メッセージの右端が画面左端まで行ったら終了
                    if ( roll >= msgsize ) : isTrainmsg = 0

                }

                // メッセージスクロール
                if ( isMsg ) {

                    // 右から左へ流す
                    pos 0-roll, textsize_y

                    msgsize = 0

                    repeat msgSections

                        if ( imsg_msg.cnt.nowMsg == 0 ) : break

                        if ( ( isBlinking and isBlinkMsg.cnt.nowMsg ) == 0 ) {

                            if ( instr( msg_msg.cnt.nowMsg, 0, "$" ) == -1 ) {

                                rgbcolor imsg_msg.cnt.nowMsg
                                mes msg_msg.cnt.nowMsg, 1

                                msgsize += ginfo_mesx
    
                            } else {
    
                                sdim tmp
                                split msg_msg.cnt.nowMsg, "$", tmp
    
                                before_cnt = cnt
    
                                if ( tmp.0 != "" ) {
    
                                    rgbcolor imsg_msg.cnt.nowMsg : mes tmp.0, 1

                                    msgsize += ginfo_mesx
    
                                }
    
                                repeat length( tmp ) -1, 1
    
                                    if ( splitedcnt == cnt ) : break

                                    celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                    rgbcolor imsg_msg.before_cnt.nowMsg : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                    msgsize += ginfo_mesx + celSize_x
    
                                loop
    
                            }

                        } else {

                            gsel SCREEN_DUMMY
                            
                            if ( instr( msg_msg.cnt.nowMsg, 0, "$" ) == -1 ) {

                                mes msg_msg.cnt.nowMsg
                                tmp = ginfo_mesx

                            } else {

                                tmp = 0

                                sdim string
                                split msg_msg.cnt.nowMsg, "$", string
    
                                before_cnt = cnt
    
                                if ( string.0 != "" ) {
    
                                    mes string.0

                                    tmp += ginfo_mesx
    
                                }
    
                                repeat length( string ) -1, 1
    
                                    if ( splitedcnt == cnt ) : break

                                    mes strmid( string.cnt, embedImageNumSize, strlen( string.cnt ) -embedImageNumSize )
                                    tmp += ginfo_mesx + celSize_x
    
                                loop

                            }

                            gsel SCREEN_S
                            msgsize += tmp
                            pos ginfo_cx + tmp, ginfo_cy

                        }

                    loop

                    if ( gettick( tickScroll ) >= 15 ) {
                        
                        settick tickScroll
                        roll ++

                    }

                    // メッセージの右端が画面左端まで行ったら終了
                    if ( roll >= msgsize ) {
                        
                        isMsg = 0
                        if ( beforeMsg != -1 ) {

                            nowMsg = beforeMsg
                            beforeMsg = -1

                        }

                    }

                }

            }

            if ( ( isCanview2ndLine ) or ( cnt != 1 ) ) {

                if ( ( nowTrain +cnt -isShiftingLine ) < entry ) {

                    if ( ( isBlinking and isBlink.eLine.( nowTrain +cnt -isShiftingLine ) ) == 0 ) {

                        if ( instr( msg_Line.isEng.( nowTrain +cnt -isShiftingLine ), 0, "$" ) == -1 ) {

                            rgbcolor imsg_Line.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine, textsize_y *cnt : mes msg_Line.isEng.( nowTrain +cnt -isShiftingLine ), 1
                            if ( isBold.eLine.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Line.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine +1, textsize_y *cnt : mes msg_Line.isEng.( nowTrain +cnt -isShiftingLine ), 1

                        } else {

                            sdim tmp
                            split msg_Line.isEng.( nowTrain +cnt -isShiftingLine ), "$", tmp

                            before_cnt = cnt
                            msgPosShift = 0

                            if ( tmp.0 != "" ) {

                                rgbcolor imsg_Line.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine, textsize_y *cnt : mes tmp.0, 1
                                if ( isBold.eLine.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Line.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine +1, textsize_y *cnt : mes tmp.0, 1        

                                msgPosShift = ginfo_mesx

                            }

                            repeat length( tmp ) -1, 1

                                if ( splitedcnt == cnt ) : break

                                pos textsize_x * msgoffset.eLine +msgPosShift, textsize_y *before_cnt
                                celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                msgPosShift += celSize_x

                                rgbcolor imsg_Line.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine +msgPosShift , textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                if ( isBold.eLine.( nowTrain +before_cnt -isShiftingLine ) ) : rgbcolor imsg_Line.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eLine +msgPosShift +1, textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1        

                                msgPosShift += ginfo_mesx

                            loop

                        }

                    }

                    if ( ( isBlinking and isBlink.eType.( nowTrain +cnt -isShiftingLine ) ) == 0 ) {

                        if ( instr( msg_Type.isEng.( nowTrain +cnt -isShiftingLine ), 0, "$" ) == -1 ) {

                            rgbcolor imsg_Type.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType, textsize_y *cnt : mes msg_Type.isEng.( nowTrain +cnt -isShiftingLine ), 1
                            if ( isBold.eType.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Type.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType +1, textsize_y *cnt : mes msg_Type.isEng.( nowTrain +cnt -isShiftingLine ), 1

                        } else {

                            sdim tmp
                            split msg_Type.isEng.( nowTrain +cnt -isShiftingLine ), "$", tmp

                            before_cnt = cnt
                            msgPosShift = 0

                            if ( tmp.0 != "" ) {

                                rgbcolor imsg_Type.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType, textsize_y *cnt : mes tmp.0, 1
                                if ( isBold.eType.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Type.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType +1, textsize_y *cnt : mes tmp.0, 1        

                                msgPosShift = ginfo_mesx

                            }

                            repeat length( tmp ) -1, 1

                                if ( splitedcnt == cnt ) : break

                                pos textsize_x * msgoffset.eType +msgPosShift, textsize_y *before_cnt
                                celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                msgPosShift += celSize_x

                                rgbcolor imsg_Type.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType +msgPosShift , textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                if ( isBold.eType.( nowTrain +before_cnt -isShiftingLine ) ) : rgbcolor imsg_Type.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eType +msgPosShift +1, textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1        

                                msgPosShift += ginfo_mesx

                            loop

                        }
                    }

                    if ( ( isBlinking and isBlink.eFor.( nowTrain +cnt -isShiftingLine ) ) == 0 ) {

                        if ( instr( msg_For.isEng.( nowTrain +cnt -isShiftingLine ), 0, "$" ) == -1 ) {

                            rgbcolor imsg_For.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor, textsize_y *cnt : mes msg_For.isEng.( nowTrain +cnt -isShiftingLine ), 1
                            if ( isBold.eFor.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_For.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor +1, textsize_y *cnt : mes msg_For.isEng.( nowTrain +cnt -isShiftingLine ), 1

                        } else {

                            sdim tmp
                            split msg_For.isEng.( nowTrain +cnt -isShiftingLine ), "$", tmp

                            before_cnt = cnt
                            msgPosShift = 0

                            if ( tmp.0 != "" ) {

                                rgbcolor imsg_For.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor, textsize_y *cnt : mes tmp.0, 1
                                if ( isBold.eFor.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_For.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor +1, textsize_y *cnt : mes tmp.0, 1        

                                msgPosShift = ginfo_mesx

                            }

                            repeat length( tmp ) -1, 1

                                if ( splitedcnt == cnt ) : break

                                pos textsize_x * msgoffset.eFor +msgPosShift, textsize_y *before_cnt
                                celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                msgPosShift += celSize_x

                                rgbcolor imsg_For.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor +msgPosShift , textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                if ( isBold.eFor.( nowTrain +before_cnt -isShiftingLine ) ) : rgbcolor imsg_For.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eFor +msgPosShift +1, textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1        

                                msgPosShift += ginfo_mesx

                            loop

                        }
                    }

                    if ( ( isBlinking and isBlink.eTime.( nowTrain +cnt -isShiftingLine ) ) == 0 ) {

                        if ( instr( msg_Time.isEng.( nowTrain +cnt -isShiftingLine ), 0, "$" ) == -1 ) {

                            rgbcolor imsg_Time.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime, textsize_y *cnt : mes msg_Time.isEng.( nowTrain +cnt -isShiftingLine ), 1
                            if ( isBold.eTime.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Time.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime +1, textsize_y *cnt : mes msg_Time.isEng.( nowTrain +cnt -isShiftingLine ), 1

                        } else {

                            sdim tmp
                            split msg_Time.isEng.( nowTrain +cnt -isShiftingLine ), "$", tmp

                            before_cnt = cnt
                            msgPosShift = 0

                            if ( tmp.0 != "" ) {

                                rgbcolor imsg_Time.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime, textsize_y *cnt : mes tmp.0, 1
                                if ( isBold.eTime.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Time.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime +1, textsize_y *cnt : mes tmp.0, 1        

                                msgPosShift = ginfo_mesx

                            }

                            repeat length( tmp ) -1, 1

                                if ( splitedcnt == cnt ) : break

                                pos textsize_x * msgoffset.eTime +msgPosShift, textsize_y *before_cnt
                                celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                msgPosShift += celSize_x

                                rgbcolor imsg_Time.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime +msgPosShift , textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                if ( isBold.eTime.( nowTrain +before_cnt -isShiftingLine ) ) : rgbcolor imsg_Time.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eTime +msgPosShift +1, textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1        

                                msgPosShift += ginfo_mesx
                                
                            loop

                        }

                    }

                    if ( ( isBlinking and isBlink.eCars.( nowTrain +cnt -isShiftingLine ) ) == 0 ) {

                        if ( instr( msg_Cars.isEng.( nowTrain +cnt -isShiftingLine ), 0, "$" ) == -1 ) {

                            rgbcolor imsg_Cars.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars, textsize_y *cnt : mes msg_Cars.isEng.( nowTrain +cnt -isShiftingLine ), 1
                            if ( isBold.eCars.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Cars.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars +1, textsize_y *cnt : mes msg_Cars.isEng.( nowTrain +cnt -isShiftingLine ), 1

                        } else {

                            sdim tmp
                            split msg_Cars.isEng.( nowTrain +cnt -isShiftingLine ), "$", tmp

                            before_cnt = cnt
                            msgPosShift = 0

                            if ( tmp.0 != "" ) {

                                rgbcolor imsg_Cars.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars, textsize_y *cnt : mes tmp.0, 1
                                if ( isBold.eCars.( nowTrain +cnt -isShiftingLine ) ) : rgbcolor imsg_Cars.( nowTrain +cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars +1, textsize_y *cnt : mes tmp.0, 1        

                                msgPosShift = ginfo_mesx

                            }

                            repeat length( tmp ) -1, 1

                                if ( splitedcnt == cnt ) : break

                                pos textsize_x * msgoffset.eCars +msgPosShift, textsize_y *before_cnt
                                celput SCREEN_CEL, int( strmid( tmp.cnt, 0, embedImageNumSize ) )

                                msgPosShift += celSize_x

                                rgbcolor imsg_Cars.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars +msgPosShift , textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1
                                if ( isBold.eCars.( nowTrain +before_cnt -isShiftingLine ) ) : rgbcolor imsg_Cars.( nowTrain +before_cnt -isShiftingLine ) : pos textsize_x * msgoffset.eCars +msgPosShift +1, textsize_y *before_cnt : mes strmid( tmp.cnt, embedImageNumSize, strlen( tmp.cnt ) -embedImageNumSize ), 1        

                                msgPosShift += ginfo_mesx
                                
                            loop

                        }

                    }

                }

            }

        loop

        redraw 1

        // コピー
        gsel SCREEN_D

        redraw 0

        gzoom (textsize_x*text_length+OFFSET_X)*SCREEN_MAG, (textsize_y*text_line+OFFSET_Y)*SCREEN_MAG, 0, 0, 0, textsize_x*text_length+OFFSET_X, textsize_y*text_line+OFFSET_Y, 0
        
        if ( isCountFps ) {

            pos 0, 0 : mes strf( "%dfps", freamrate )

            if ( isFlash ) {

                color 255, 255, 255 : boxf 0, 0, ginfo_mesx +1, ginfo_mesy +1
                color 0, 0, 0 : pos 0, 0 : mes strf( "%dfps", freamrate )
                
                isFlash --

            } else {

                color 0, 0, 0 : boxf 0, 0, ginfo_mesx +1, ginfo_mesy +1
                color 255, 255, 255 : pos 0, 0 : mes strf( "%dfps", freamrate )

            }

        }

        pos 0, 0

        redraw 1

        // 5秒ごとに日本語・英語切り替わり
        if ( gettick( tickLangChange ) >= 5000 ) {

            settick tickLangChange

            if ( isEng ) {

                isEng = 0

            } else {

                isEng = 1

            }

        }

        // 列車接近メッセージ点滅制御　1秒周期の0.5秒間隔
        if ( ( gettick( tickTrainBlink ) >= 500 ) and ( isApproaching ) ){

            settick tickTrainBlink

            if ( isApproachingView ) {

                isApproachingView = 0

            } else {

                isApproachingView = 1

            }

        }

        // 種別・行先・時刻・両数　点滅動作　1秒ごとに滅
        if ( gettick( tickSomeBlinkInterval ) >= 1000 ) {

            settick tickSomeBlinkInterval
            settick tickSomeBlinkDown

            isBlinking = 1

        }

        // 種別・行先・時刻・両数　タイマ動作　滅から0.2秒で点
        if ( isBlinking ) {

            if ( gettick( tickSomeBlinkDown ) >= 200 ) {

                isBlinking = 0

            }

        }

        if ( isCountFps ) {

            waitticks ++

            if ( gettick( tickFpsCount ) >= 1000 ) {

                settick tickFpsCount

                freamrate = waitticks
                waitticks = 0

                isFlash = 5

            }

        }

        await 10

    loop

    goto *reset

*l_approaching_true

    // 列車接近セット
    // メッセージ系削除
    isApproaching = 1
    isTrainmsg = 0
    isMsg = 0
    if ( beforeMsg != -1 ) {

        nowMsg = beforeMsg
        beforeMsg = -1

    }
    isApproachingView = 0

    return

*l_approaching_false

    // 列車接近リセット
    isApproaching = 0
    isApproachingView = 0

    return

*l_msg

    // メッセージ表示
    // 列車接近中はキャンセル
    if ( isApproaching ) : return

    isMsg = 1
    if ( beforeMsg != -1 ) {

        nowMsg = beforeMsg
        beforeMsg = -1

    }
    isTrainmsg = 0
    roll = ( textsize_x * text_length + OFFSET_X ) *-1 ; 画面右端から始まるようにする

    return

*l_trainmsg

    // 列車メッセージ表示
    // 列車接近中はキャンセル
    if ( isApproaching ) : return

    isTrainmsg = 1
    isMsg = 0
    if ( beforeMsg != -1 ) {

        nowMsg = beforeMsg
        beforeMsg = -1

    }
    roll = ( textsize_x * text_length + OFFSET_X ) *-1 ; 画面右端から始まるようにする
    return

*l_next

    // 列車順送り
    // 最後尾ならキャンセル
    if ( ( nowTrain ) == entry -1 ) : return

    nowTrain ++

    return

*l_prev

    // 列車戻し
    // 先頭ならキャンセル
    if ( nowTrain == 0 ) : return

    nowTrain --

    return

*l_nextmsg

    // メッセージ順送り
    // 最後尾ならキャンセル
    if ( ( nowMsg ) == msgEntry -1 ) : return

    nowMsg ++

    return

*l_prevmsg

    // メッセージ戻し
    // 先頭ならキャンセル
    if ( nowMsg == 0 ) : return

    nowMsg --

    return

*l_save

    bmpsave "pic"+ gettime(0) +"-"+ gettime(1) +"-"+ gettime(3) +"-"+ gettime(4) +"-"+ gettime(5) +"-"+ gettime(6) +".bmp"

    return

*l_author

    dialog "製作：秋月\n\nこのソフトウエアを使用したことで生じた損害について、製作者はいかなる場合でも一切責任を負いません。\n\nCopyright (c) 2024 AkidukiSystems All Right Reserved.\n  www.akidukisystems.com"

    return

*l_select

    nowDirectory = dir_cur

    dialog "ini|ein|ceini", 16, "File|Encrypted file|Compressed encrypted file"

    chdir nowDirectory

    if ( stat != 1 ) : return

    isChangedFile = 1
    nowLoadingFile = refstr

    PostMessage hwnd, MSG_CHANGED_DATA, 2, 0

    return

*l_smartview_write

    vsave ""+ gettime(0) +"-"+ gettime(1) +"-"+ gettime(3) +"-"+ gettime(4) +"-"+ gettime(5) +"-"+ gettime(6) +".smv"

    return

*l_smartview_read

    nowDirectory = dir_cur

    dialog "smv", 16, "スマートビューファイル"

    chdir nowDirectory

    if ( stat ) {

        vload refstr

        PostMessage hwnd, MSG_CHANGED_DATA, 1, 0

    }

    return

*l_changed_data

    switch wparam

        case 1

            goto *l_SMVloaded

        swbreak
        case 2

            goto *reset

        swbreak

    swend

    stop

*l_passwordEnter

    isPasswordEnter = 1

    return

*l_passwordCancel

    isPasswordCancel = 1

    return

*l_extramsg

    gsel SCREEN_EXTRAMSG, 1
    cls
    color

    objsize 100, 20, 0

    foreach msg_extra

        pos 0, 20 *cnt *2
        mes "第"+ cnt +"セクション :"

        pos ginfo_mesx, 20 *cnt *2
        input msg_extra.cnt, 640 -ginfo_mesx, 20, 0

        pos ginfo_mesx, 20 *cnt *2 +20
        input imsg_extra.cnt, 100, 20, 6

        pos ginfo_mesx +100, 20 *cnt *2 +20
        combox isBlinkExtraMsg.cnt, 0, "点滅しない\n点滅する"


    loop

    objsize 128, 32, 0
    pos 0, ginfo_cy

    button gosub "表示", *l_submit

    return

*l_submit

    // メッセージ表示
    // 列車接近中はキャンセル
    if ( isApproaching ) : return

    foreach msg_extra

        msg_msg.cnt.msgEntry = msg_extra.cnt

    loop

    foreach imsg_extra

        imsg_msg.cnt.msgEntry = int( "$"+ imsg_extra.cnt )

    loop

    foreach isBlinkExtraMsg

        isBlinkMsg.cnt.msgEntry = isBlinkExtraMsg.cnt

    loop

    if ( beforeMsg == -1 ) {

        beforeMsg = nowMsg
        nowMsg = msgEntry

    }

    isMsg = 1
    isTrainmsg = 0
    roll = ( textsize_x * text_length + OFFSET_X ) *-1 ; 画面右端から始まるようにする

    return

*l_exit

    if ( ginfo_act == SCREEN_D ) : end
    if ( ginfo_act == SCREEN_CONTROL ) : end
    
    gsel ginfo_act, -1

    return

*l_config

    gsel SCREEN_CONFIG, 1

    return

*l_config_fpschange

    if ( isCountFps ) {

        isCountFps = 0

    } else {

        isCountFps = 1

    }

    return

*l_config_log

    gsel SCREEN_LOG, 1

    return